<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/DME.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/DME.java" />
              <option name="originalContent" value="import java.io.IOException;&#10;import java.util.Comparator;&#10;import java.util.Map;&#10;import java.util.PriorityQueue;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;public class DME {&#10;&#10;    private int pid;&#10;&#10;    private Map&lt;Integer, String&gt; peerHosts; // pid -&gt; host:port&#10;&#10;    private Transport transport;&#10;&#10;    private LamportClock clock;&#10;&#10;    private PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(&#10;        Comparator.&lt;int[]&gt; comparingInt(a -&gt; a[0]).thenComparingInt(a -&gt; a[1]));&#10;&#10;    private Set&lt;Integer&gt; replies = ConcurrentHashMap.newKeySet();&#10;&#10;    private volatile boolean wantCS = false;&#10;&#10;    public DME(int pid, Map&lt;Integer, String&gt; peers, Transport tr, LamportClock clock) {&#10;        this.pid = pid;&#10;        this.peerHosts = peers;&#10;        this.transport = tr;&#10;        this.clock = clock;&#10;    }&#10;&#10;    public void start() {&#10;        new Thread(() -&gt; {&#10;            while (true) {&#10;                try {&#10;                    Message msg = transport.inbox.take();&#10;                    clock.tickReceive(msg.ts);&#10;                    switch (msg.type) {&#10;                        case &quot;REQUEST&quot;:&#10;                            queue.add(new int[] { msg.ts, msg.from });&#10;                            if(!wantCS || isLowerPriority(msg.ts, msg.from)) {&#10;                                sendTo(msg.from, &quot;REPLY&quot;);&#10;                            }&#10;                            break;&#10;                        case &quot;REPLY&quot;:&#10;                            replies.add(msg.from);&#10;                            break;&#10;                        case &quot;RELEASE&quot;:&#10;                            queue.removeIf(e -&gt; e[1] == msg.from);&#10;                            break;&#10;                    }&#10;                } catch (InterruptedException | IOException e) {break;}&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void requestCS() throws IOException, InterruptedException {&#10;        wantCS = true;&#10;        int ts = clock.tickSend();&#10;        queue.add(new int[] { ts, pid });&#10;        for(int peerId : peerHosts.keySet()) {&#10;            sendTo(peerId, &quot;REQUEST&quot;);&#10;        }&#10;        while (!(queue.peek()[1] == pid &amp;&amp; replies.size() == peerHosts.size())) {&#10;            Thread.sleep(10);&#10;        }&#10;    }&#10;&#10;    public void releaseCS() throws IOException {&#10;        wantCS = false;&#10;        queue.poll();&#10;        int ts = clock.tickSend();&#10;        for(int peerId : peerHosts.keySet()) {&#10;            sendTo(peerId, &quot;RELEASE&quot;);&#10;        }&#10;        replies.clear();&#10;    }&#10;&#10;    private boolean isLowerPriority(int ts, int from) {&#10;        int[] mine = queue.stream().filter(e -&gt; e[1] == pid).findFirst().orElse(null);&#10;        if(mine == null) {return true;}&#10;        return ts &lt; mine[0] || (ts == mine[0] &amp;&amp; from &lt; pid);&#10;    }&#10;&#10;    private void sendTo(int peerId, String type) throws IOException {&#10;        int ts = clock.tickSend();&#10;        String[] hp = peerHosts.get(peerId).split(&quot;:&quot;);&#10;        transport.send(hp[0], Integer.parseInt(hp[1]), new Message(type, ts, pid));&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import java.io.IOException;&#10;import java.util.Comparator;&#10;import java.util.Map;&#10;import java.util.PriorityQueue;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;public class DME {&#10;&#10;    private int pid;&#10;&#10;    private Map&lt;Integer, String&gt; peerHosts; // pid -&gt; host:port&#10;&#10;    private Transport transport;&#10;&#10;    private LamportClock clock;&#10;&#10;    private PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(&#10;        Comparator.&lt;int[]&gt; comparingInt(a -&gt; a[0]).thenComparingInt(a -&gt; a[1]));&#10;&#10;    private Set&lt;Integer&gt; replies = ConcurrentHashMap.newKeySet();&#10;&#10;    private volatile boolean wantCS = false;&#10;    private volatile boolean running = true;&#10;&#10;    public DME(int pid, Map&lt;Integer, String&gt; peers, Transport tr, LamportClock clock) {&#10;        this.pid = pid;&#10;        this.peerHosts = peers;&#10;        this.transport = tr;&#10;        this.clock = clock;&#10;    }&#10;&#10;    public void start() {&#10;        new Thread(() -&gt; {&#10;            while (running) {&#10;                try {&#10;                    Message msg = transport.inbox.take();&#10;                    clock.tickReceive(msg.ts);&#10;                    switch (msg.type) {&#10;                        case &quot;REQUEST&quot;:&#10;                            queue.add(new int[] { msg.ts, msg.from });&#10;                            if(!wantCS || isLowerPriority(msg.ts, msg.from)) {&#10;                                sendTo(msg.from, &quot;REPLY&quot;);&#10;                            }&#10;                            break;&#10;                        case &quot;REPLY&quot;:&#10;                            replies.add(msg.from);&#10;                            break;&#10;                        case &quot;RELEASE&quot;:&#10;                            queue.removeIf(e -&gt; e[1] == msg.from);&#10;                            break;&#10;                    }&#10;                } catch (InterruptedException | IOException e) {&#10;                    if (running) {&#10;                        e.printStackTrace();&#10;                    }&#10;                    break;&#10;                }&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void shutdown() {&#10;        running = false;&#10;        // Add a dummy message to unblock the thread waiting on inbox.take()&#10;        try {&#10;            transport.inbox.put(new Message(&quot;SHUTDOWN&quot;, 0, -1));&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;&#10;    public void requestCS() throws IOException, InterruptedException {&#10;        wantCS = true;&#10;        int ts = clock.tickSend();&#10;        queue.add(new int[] { ts, pid });&#10;        for(int peerId : peerHosts.keySet()) {&#10;            sendTo(peerId, &quot;REQUEST&quot;);&#10;        }&#10;        while (!(queue.peek()[1] == pid &amp;&amp; replies.size() == peerHosts.size())) {&#10;            Thread.sleep(10);&#10;        }&#10;    }&#10;&#10;    public void releaseCS() throws IOException {&#10;        wantCS = false;&#10;        queue.poll();&#10;        int ts = clock.tickSend();&#10;        for(int peerId : peerHosts.keySet()) {&#10;            sendTo(peerId, &quot;RELEASE&quot;);&#10;        }&#10;        replies.clear();&#10;    }&#10;&#10;    private boolean isLowerPriority(int ts, int from) {&#10;        int[] mine = queue.stream().filter(e -&gt; e[1] == pid).findFirst().orElse(null);&#10;        if(mine == null) {return true;}&#10;        return ts &lt; mine[0] || (ts == mine[0] &amp;&amp; from &lt; pid);&#10;    }&#10;&#10;    private void sendTo(int peerId, String type) throws IOException {&#10;        int ts = clock.tickSend();&#10;        String[] hp = peerHosts.get(peerId).split(&quot;:&quot;);&#10;        transport.send(hp[0], Integer.parseInt(hp[1]), new Message(type, ts, pid));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Main.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Main.java" />
              <option name="originalContent" value="import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Random;&#10;&#10;public class Main {&#10;&#10;    static void writePattern(String filename, String content) {&#10;        try (FileWriter fw = new FileWriter(filename, true)) {&#10;            fw.write(content);&#10;            fw.flush();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) throws Exception {&#10;        if(args.length &lt; 5) {&#10;            System.err.println(&#10;                &quot;Usage: java Main &lt;pid&gt; &lt;port&gt; &lt;peer1:host:port,...&gt; &lt;filename&gt; &lt;with-dme|without-dme&gt;&quot;);&#10;            System.exit(1);&#10;        }&#10;&#10;        int pid = Integer.parseInt(args[0]);&#10;        int port = Integer.parseInt(args[1]);&#10;        String peersArg = args[2];&#10;        String filename = args[3];&#10;        boolean withDME = args[4].equalsIgnoreCase(&quot;with-dme&quot;);&#10;&#10;        Map&lt;Integer, String&gt; peers = new HashMap&lt;&gt;();&#10;        for(String peer : peersArg.split(&quot;,&quot;)) {&#10;            String[] parts = peer.split(&quot;:&quot;);&#10;            if(parts.length != 3) {&#10;                System.err.println(&quot;Peer format must be pid:host:port&quot;);&#10;                System.exit(1);&#10;            }&#10;            int peerId = Integer.parseInt(parts[0]);&#10;            peers.put(peerId, parts[1] + &quot;:&quot; + parts[2]);&#10;        }&#10;        peers.remove(pid); // exclude self&#10;&#10;        Transport transport = new Transport(port);&#10;        transport.start();&#10;&#10;        LamportClock clock = new LamportClock();&#10;&#10;        DME dme = new DME(pid, peers, transport, clock);&#10;        dme.start();&#10;&#10;        // Wait a moment for all nodes to start&#10;        Thread.sleep(2000);&#10;&#10;        for(int i = 0; i &lt; 200; i++) {&#10;            if(withDME) {&#10;                dme.requestCS();&#10;                writePattern(filename, &quot;|&quot;);&#10;                writePattern(filename, &quot;.&quot;);&#10;                dme.releaseCS();&#10;            } else {&#10;                writePattern(filename, &quot;|&quot;);&#10;                writePattern(filename, &quot;.&quot;);&#10;            }&#10;        }&#10;        System.out.println(&quot;Process &quot; + pid + &quot; finished.&quot;);&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;import java.util.Random;&#10;&#10;public class Main {&#10;&#10;    static void writePattern(String filename, String content) {&#10;        try (FileWriter fw = new FileWriter(filename, true)) {&#10;            fw.write(content);&#10;            fw.flush();&#10;        } catch (IOException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) throws Exception {&#10;        if(args.length &lt; 5) {&#10;            System.err.println(&#10;                &quot;Usage: java Main &lt;pid&gt; &lt;port&gt; &lt;peer1:host:port,...&gt; &lt;filename&gt; &lt;with-dme|without-dme&gt;&quot;);&#10;            System.exit(1);&#10;        }&#10;&#10;        int pid = Integer.parseInt(args[0]);&#10;        int port = Integer.parseInt(args[1]);&#10;        String peersArg = args[2];&#10;        String filename = args[3];&#10;        boolean withDME = args[4].equalsIgnoreCase(&quot;with-dme&quot;);&#10;&#10;        Map&lt;Integer, String&gt; peers = new HashMap&lt;&gt;();&#10;        for(String peer : peersArg.split(&quot;,&quot;)) {&#10;            String[] parts = peer.split(&quot;:&quot;);&#10;            if(parts.length != 3) {&#10;                System.err.println(&quot;Peer format must be pid:host:port&quot;);&#10;                System.exit(1);&#10;            }&#10;            int peerId = Integer.parseInt(parts[0]);&#10;            peers.put(peerId, parts[1] + &quot;:&quot; + parts[2]);&#10;        }&#10;        peers.remove(pid); // exclude self&#10;&#10;        Transport transport = new Transport(port);&#10;        transport.start();&#10;&#10;        LamportClock clock = new LamportClock();&#10;&#10;        DME dme = new DME(pid, peers, transport, clock);&#10;        dme.start();&#10;&#10;        // Wait a moment for all nodes to start&#10;        Thread.sleep(2000);&#10;&#10;        for(int i = 0; i &lt; 200; i++) {&#10;            if(withDME) {&#10;                dme.requestCS();&#10;                writePattern(filename, &quot;|&quot;);&#10;                writePattern(filename, &quot;.&quot;);&#10;                dme.releaseCS();&#10;            } else {&#10;                writePattern(filename, &quot;|&quot;);&#10;                writePattern(filename, &quot;.&quot;);&#10;            }&#10;        }&#10;        &#10;        // Clean shutdown&#10;        dme.shutdown();&#10;        transport.shutdown();&#10;        &#10;        System.out.println(&quot;Process &quot; + pid + &quot; finished.&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Process.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Process.java" />
              <option name="originalContent" value="import java.io.BufferedReader;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.io.InputStreamReader;&#10;import java.io.PrintWriter;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;public class Process {&#10;&#10;    private int processId;&#10;&#10;    private List&lt;String&gt; peers;&#10;&#10;    private boolean useDME;&#10;&#10;    private int logicalClock;&#10;&#10;    private Map&lt;Integer, Integer&gt; requestQueue;&#10;&#10;    private Set&lt;Integer&gt; replies;&#10;&#10;    private boolean requestingCS;&#10;&#10;    private ServerSocket serverSocket;&#10;&#10;    private static final String OUTPUT_FILE = &quot;output.txt&quot;;&#10;&#10;    public Process(int processId, List&lt;String&gt; peers, boolean useDME) {&#10;        this.processId = processId;&#10;        this.peers = new ArrayList&lt;&gt;(peers);&#10;        this.useDME = useDME;&#10;        this.logicalClock = 0;&#10;        this.requestQueue = new ConcurrentHashMap&lt;&gt;();&#10;        this.replies = new HashSet&lt;&gt;();&#10;        this.requestingCS = false;&#10;&#10;        try {&#10;            this.serverSocket = new ServerSocket(8000 + processId);&#10;            System.out.println(&quot;Process &quot; + processId + &quot; started on port &quot; + (8000 + processId));&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Failed to start server: &quot; + e.getMessage());&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    public void start() {&#10;        // Start message listener in background&#10;        Thread listener = new Thread(this::listenForMessages);&#10;        listener.setDaemon(true);&#10;        listener.start();&#10;&#10;        // Main process loop&#10;        while (true) {&#10;            if(useDME) {&#10;                requestCriticalSection();&#10;                writeToFile();&#10;                releaseCriticalSection();&#10;            } else {&#10;                writeToFile();&#10;            }&#10;        }&#10;    }&#10;&#10;    private void writeToFile() {&#10;        try (FileWriter writer = new FileWriter(OUTPUT_FILE, true)) {&#10;            writer.write(&quot;|&quot;);&#10;            writer.flush();&#10;            Thread.sleep(50); // Small delay between writes&#10;            writer.write(&quot;.&quot;);&#10;            writer.flush();&#10;            System.out.println(&quot;Process &quot; + processId + &quot; wrote |.&quot;);&#10;        } catch (IOException | InterruptedException e) {&#10;            System.err.println(&quot;Error writing to file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void requestCriticalSection() {&#10;        requestingCS = true;&#10;        logicalClock++;&#10;        replies.clear();&#10;&#10;        // Add our own request to the queue - THIS WAS MISSING!&#10;        requestQueue.put(processId, logicalClock);&#10;&#10;        // Send request to all peers&#10;        for(String peer : peers) {&#10;            sendMessage(peer, &quot;REQUEST &quot; + logicalClock + &quot; &quot; + processId);&#10;        }&#10;&#10;        // Wait for all replies&#10;        while (replies.size() &lt; peers.size()) {&#10;            try {&#10;                Thread.sleep(10);&#10;            } catch (InterruptedException e) {&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Wait until we're at the front of our own queue&#10;        while (!isAtFrontOfQueue()) {&#10;            try {&#10;                Thread.sleep(10);&#10;            } catch (InterruptedException e) {&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void releaseCriticalSection() {&#10;        requestingCS = false;&#10;        requestQueue.remove(processId);&#10;&#10;        // Send release to all peers&#10;        for(String peer : peers) {&#10;            sendMessage(peer, &quot;RELEASE &quot; + processId);&#10;        }&#10;    }&#10;&#10;    private boolean isAtFrontOfQueue() {&#10;        if(!requestQueue.containsKey(processId)) {&#10;            return false;&#10;        }&#10;&#10;        int myTimestamp = requestQueue.get(processId);&#10;        for(Map.Entry&lt;Integer, Integer&gt; entry : requestQueue.entrySet()) {&#10;            int otherTimestamp = entry.getValue();&#10;            int otherId = entry.getKey();&#10;&#10;            if(otherTimestamp &lt; myTimestamp || (otherTimestamp == myTimestamp &amp;&amp; otherId &lt; processId)) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private void listenForMessages() {&#10;        while (true) {&#10;            try {&#10;                Socket client = serverSocket.accept();&#10;                BufferedReader reader = new BufferedReader(&#10;                    new InputStreamReader(client.getInputStream()));&#10;                String message = reader.readLine();&#10;&#10;                if(message != null) {&#10;                    handleMessage(message, client);&#10;                }&#10;&#10;                client.close();&#10;            } catch (IOException e) {&#10;                // Continue listening&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleMessage(String message, Socket sender) {&#10;        String[] parts = message.split(&quot; &quot;);&#10;        String type = parts[0];&#10;&#10;        logicalClock = Math.max(logicalClock, Integer.parseInt(parts[1])) + 1;&#10;&#10;        if(&quot;REQUEST&quot;.equals(type)) {&#10;            int timestamp = Integer.parseInt(parts[1]);&#10;            int senderId = Integer.parseInt(parts[2]);&#10;&#10;            requestQueue.put(senderId, timestamp);&#10;&#10;            // Send reply&#10;            try {&#10;                PrintWriter writer = new PrintWriter(sender.getOutputStream());&#10;                writer.println(&quot;REPLY &quot; + logicalClock + &quot; &quot; + processId);&#10;                writer.flush();&#10;            } catch (IOException e) {&#10;                System.err.println(&quot;Error sending reply: &quot; + e.getMessage());&#10;            }&#10;&#10;        } else if(&quot;REPLY&quot;.equals(type)) {&#10;            int senderId = Integer.parseInt(parts[2]);&#10;            replies.add(senderId);&#10;&#10;        } else if(&quot;RELEASE&quot;.equals(type)) {&#10;            int senderId = Integer.parseInt(parts[1]);&#10;            requestQueue.remove(senderId);&#10;        }&#10;    }&#10;&#10;    private void sendMessage(String peer, String message) {&#10;        try {&#10;            String[] parts = peer.split(&quot;:&quot;);&#10;            String host = parts[0];&#10;            int port = Integer.parseInt(parts[1]);&#10;&#10;            Socket socket = new Socket(host, port);&#10;            PrintWriter writer = new PrintWriter(socket.getOutputStream());&#10;            writer.println(message);&#10;            writer.flush();&#10;&#10;            if(message.startsWith(&quot;REQUEST&quot;)) {&#10;                BufferedReader reader = new BufferedReader(&#10;                    new InputStreamReader(socket.getInputStream()));&#10;                String reply = reader.readLine();&#10;                if(reply != null &amp;&amp; reply.startsWith(&quot;REPLY&quot;)) {&#10;                    String[] replyParts = reply.split(&quot; &quot;);&#10;                    int senderId = Integer.parseInt(replyParts[2]);&#10;                    replies.add(senderId);&#10;                }&#10;            }&#10;&#10;            socket.close();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error sending message to &quot; + peer + &quot;: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        if(args.length &lt; 3) {&#10;            System.err.println(&#10;                &quot;Usage: java Process &lt;processId&gt; &lt;useDME&gt; &lt;peer1:port&gt; [peer2:port] ...&quot;);&#10;            System.exit(1);&#10;        }&#10;&#10;        int processId = Integer.parseInt(args[0]);&#10;        boolean useDME = Boolean.parseBoolean(args[1]);&#10;&#10;        List&lt;String&gt; peers = new ArrayList&lt;&gt;();&#10;        for(int i = 2; i &lt; args.length; i++) {&#10;            peers.add(args[i]);&#10;        }&#10;&#10;        Process process = new Process(processId, peers, useDME);&#10;        process.start();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.io.BufferedReader;&#10;import java.io.FileWriter;&#10;import java.io.IOException;&#10;import java.io.InputStreamReader;&#10;import java.io.PrintWriter;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.ArrayList;&#10;import java.util.HashSet;&#10;import java.util.List;&#10;import java.util.Map;&#10;import java.util.Set;&#10;import java.util.concurrent.ConcurrentHashMap;&#10;&#10;public class Process {&#10;&#10;    private int processId;&#10;&#10;    private List&lt;String&gt; peers;&#10;&#10;    private boolean useDME;&#10;&#10;    private int logicalClock;&#10;&#10;    private Map&lt;Integer, Integer&gt; requestQueue;&#10;&#10;    private Set&lt;Integer&gt; replies;&#10;&#10;    private boolean requestingCS;&#10;&#10;    private ServerSocket serverSocket;&#10;&#10;    private static final String OUTPUT_FILE = &quot;output.txt&quot;;&#10;&#10;    public Process(int processId, List&lt;String&gt; peers, boolean useDME) {&#10;        this.processId = processId;&#10;        this.peers = new ArrayList&lt;&gt;(peers);&#10;        this.useDME = useDME;&#10;        this.logicalClock = 0;&#10;        this.requestQueue = new ConcurrentHashMap&lt;&gt;();&#10;        this.replies = new HashSet&lt;&gt;();&#10;        this.requestingCS = false;&#10;&#10;        try {&#10;            this.serverSocket = new ServerSocket(8000 + processId);&#10;            System.out.println(&quot;Process &quot; + processId + &quot; started on port &quot; + (8000 + processId));&#10;&#10;            // Start message listener immediately in constructor&#10;            Thread listener = new Thread(this::listenForMessages);&#10;            listener.setDaemon(false); // Make it a non-daemon thread&#10;            listener.start();&#10;&#10;            // Give listener a moment to be ready&#10;            Thread.sleep(100);&#10;&#10;        } catch (IOException | InterruptedException e) {&#10;            System.err.println(&quot;Failed to start server: &quot; + e.getMessage());&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    public void start() {&#10;        // Main process loop - listener is already running&#10;        while (true) {&#10;            try {&#10;                if (useDME) {&#10;                    requestCriticalSection();&#10;                    writeToFile();&#10;                    releaseCriticalSection();&#10;                } else {&#10;                    writeToFile();&#10;                }&#10;                Thread.sleep(1000);&#10;            } catch (InterruptedException e) {&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void writeToFile() {&#10;        try (FileWriter writer = new FileWriter(OUTPUT_FILE, true)) {&#10;            writer.write(&quot;|&quot;);&#10;            writer.flush();&#10;            Thread.sleep(50); // Small delay between writes&#10;            writer.write(&quot;.&quot;);&#10;            writer.flush();&#10;            System.out.println(&quot;Process &quot; + processId + &quot; wrote |.&quot;);&#10;        } catch (IOException | InterruptedException e) {&#10;            System.err.println(&quot;Error writing to file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void requestCriticalSection() {&#10;        requestingCS = true;&#10;        logicalClock++;&#10;        replies.clear();&#10;&#10;        // Add our own request to the queue - THIS WAS MISSING!&#10;        requestQueue.put(processId, logicalClock);&#10;&#10;        // Send request to all peers&#10;        for (String peer : peers) {&#10;            sendMessage(peer, &quot;REQUEST &quot; + logicalClock + &quot; &quot; + processId);&#10;        }&#10;&#10;        // Wait for all replies&#10;        while (replies.size() &lt; peers.size()) {&#10;            try {&#10;                Thread.sleep(10);&#10;            } catch (InterruptedException e) {&#10;                break;&#10;            }&#10;        }&#10;&#10;        // Wait until we're at the front of our own queue&#10;        while (!isAtFrontOfQueue()) {&#10;            try {&#10;                Thread.sleep(10);&#10;            } catch (InterruptedException e) {&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void releaseCriticalSection() {&#10;        requestingCS = false;&#10;        requestQueue.remove(processId);&#10;&#10;        // Send release to all peers&#10;        for (String peer : peers) {&#10;            sendMessage(peer, &quot;RELEASE &quot; + processId);&#10;        }&#10;    }&#10;&#10;    private boolean isAtFrontOfQueue() {&#10;        if (!requestQueue.containsKey(processId)) {&#10;            return false;&#10;        }&#10;&#10;        int myTimestamp = requestQueue.get(processId);&#10;        for (Map.Entry&lt;Integer, Integer&gt; entry : requestQueue.entrySet()) {&#10;            int otherTimestamp = entry.getValue();&#10;            int otherId = entry.getKey();&#10;&#10;            if (otherTimestamp &lt; myTimestamp || (otherTimestamp == myTimestamp &amp;&amp; otherId &lt; processId)) {&#10;                return false;&#10;            }&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private void listenForMessages() {&#10;        while (true) {&#10;            try {&#10;                Socket client = serverSocket.accept();&#10;                BufferedReader reader = new BufferedReader(&#10;                        new InputStreamReader(client.getInputStream()));&#10;                String message = reader.readLine();&#10;&#10;                if (message != null) {&#10;                    handleMessage(message, client);&#10;                }&#10;&#10;                client.close();&#10;            } catch (IOException e) {&#10;                // Continue listening&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleMessage(String message, Socket sender) {&#10;        String[] parts = message.split(&quot; &quot;);&#10;        String type = parts[0];&#10;&#10;        logicalClock = Math.max(logicalClock, Integer.parseInt(parts[1])) + 1;&#10;&#10;        if (&quot;REQUEST&quot;.equals(type)) {&#10;            int timestamp = Integer.parseInt(parts[1]);&#10;            int senderId = Integer.parseInt(parts[2]);&#10;&#10;            requestQueue.put(senderId, timestamp);&#10;&#10;            // Send reply&#10;            try {&#10;                PrintWriter writer = new PrintWriter(sender.getOutputStream());&#10;                writer.println(&quot;REPLY &quot; + logicalClock + &quot; &quot; + processId);&#10;                writer.flush();&#10;            } catch (IOException e) {&#10;                System.err.println(&quot;Error sending reply: &quot; + e.getMessage());&#10;            }&#10;&#10;        } else if (&quot;REPLY&quot;.equals(type)) {&#10;            int senderId = Integer.parseInt(parts[2]);&#10;            replies.add(senderId);&#10;&#10;        } else if (&quot;RELEASE&quot;.equals(type)) {&#10;            int senderId = Integer.parseInt(parts[1]);&#10;            requestQueue.remove(senderId);&#10;        }&#10;    }&#10;&#10;    private void sendMessage(String peer, String message) {&#10;        try {&#10;            String[] parts = peer.split(&quot;:&quot;);&#10;            String host = parts[0];&#10;            int port = Integer.parseInt(parts[1]);&#10;&#10;            Socket socket = new Socket(host, port);&#10;            PrintWriter writer = new PrintWriter(socket.getOutputStream());&#10;            writer.println(message);&#10;            writer.flush();&#10;&#10;            if (message.startsWith(&quot;REQUEST&quot;)) {&#10;                BufferedReader reader = new BufferedReader(&#10;                        new InputStreamReader(socket.getInputStream()));&#10;                String reply = reader.readLine();&#10;                if (reply != null &amp;&amp; reply.startsWith(&quot;REPLY&quot;)) {&#10;                    String[] replyParts = reply.split(&quot; &quot;);&#10;                    int senderId = Integer.parseInt(replyParts[2]);&#10;                    replies.add(senderId);&#10;                }&#10;            }&#10;&#10;            socket.close();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error sending message to &quot; + peer + &quot;: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        if (args.length &lt; 3) {&#10;            System.err.println(&#10;                    &quot;Usage: java Process &lt;processId&gt; &lt;useDME&gt; &lt;peer1:port&gt; [peer2:port] ...&quot;);&#10;            System.exit(1);&#10;        }&#10;&#10;        int processId = Integer.parseInt(args[0]);&#10;        boolean useDME = Boolean.parseBoolean(args[1]);&#10;&#10;        List&lt;String&gt; peers = new ArrayList&lt;&gt;();&#10;        for (int i = 2; i &lt; args.length; i++) {&#10;            peers.add(args[i]);&#10;        }&#10;&#10;        Process process = new Process(processId, peers, useDME);&#10;        process.start();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/README.md" />
              <option name="updatedContent" value="# Distributed Mutual Exclusion System&#10;&#10;This project implements a distributed mutual exclusion system using Lamport's Algorithm. Each process writes &quot;|&quot; followed by &quot;.&quot; to a shared file, either with or without coordination.&#10;&#10;## Files&#10;&#10;- `Process.java` - Main Java implementation&#10;- `run.sh` - Bash script to compile and start processes&#10;- `output.txt` - Shared file where processes write (created automatically)&#10;&#10;## Usage&#10;&#10;### Running without Distributed Mutual Exclusion&#10;&#10;Open 3 terminals and run:&#10;&#10;**Terminal 1:**&#10;```bash&#10;./run.sh --no-dme --process-id 1&#10;```&#10;&#10;**Terminal 2:**&#10;```bash&#10;./run.sh --no-dme --process-id 2&#10;```&#10;&#10;**Terminal 3:**&#10;```bash&#10;./run.sh --no-dme --process-id 3&#10;```&#10;&#10;### Running with Distributed Mutual Exclusion&#10;&#10;Open 3 terminals and run:&#10;&#10;**Terminal 1:**&#10;```bash&#10;./run.sh --dme --process-id 1&#10;```&#10;&#10;**Terminal 2:**&#10;```bash&#10;./run.sh --dme --process-id 2&#10;```&#10;&#10;**Terminal 3:**&#10;```bash&#10;./run.sh --dme --process-id 3&#10;```&#10;&#10;## How it Works&#10;&#10;### Without DME&#10;- Each process continuously writes &quot;|.&quot; to the file without coordination&#10;- You'll likely see interleaved characters like &quot;|.|.|.|.|.|.&quot;&#10;&#10;### With DME (Lamport's Algorithm)&#10;- Each process requests permission before accessing the file&#10;- Uses logical clocks and message passing for coordination&#10;- Ensures atomic &quot;|.&quot; writes, so you'll see clean patterns like &quot;|.|.|.|.|.|.&quot;&#10;&#10;## Network Configuration&#10;&#10;- Process 1 runs on port 8001&#10;- Process 2 runs on port 8002  &#10;- Process 3 runs on port 8003&#10;&#10;Each process connects to the other two as peers.&#10;&#10;## Output&#10;&#10;Monitor the `output.txt` file to see the difference between coordinated and uncoordinated access:&#10;&#10;```bash&#10;tail -f output.txt&#10;```" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Transport.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Transport.java" />
              <option name="originalContent" value="import java.io.IOException;&#10;import java.io.ObjectInputStream;&#10;import java.io.ObjectOutputStream;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;&#10;public class Transport {&#10;&#10;    private int port;&#10;&#10;    public BlockingQueue&lt;Message&gt; inbox = new LinkedBlockingQueue&lt;&gt;();&#10;&#10;    public Transport(int port) {&#10;        this.port = port;&#10;    }&#10;&#10;    public void start() {&#10;        new Thread(() -&gt; {&#10;            try (ServerSocket server = new ServerSocket(port)) {&#10;                while (true) {&#10;                    Socket socket = server.accept();&#10;                    try (ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {&#10;                        Message msg = (Message)in.readObject();&#10;                        inbox.put(msg);&#10;                    } catch (ClassNotFoundException e) {&#10;                        e.printStackTrace();&#10;                    }&#10;                }&#10;            } catch (IOException | InterruptedException e) {&#10;                e.printStackTrace();&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void send(String host, int port, Message msg) throws IOException {&#10;        try (Socket socket = new Socket(host, port);&#10;            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream())) {&#10;            out.writeObject(msg);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import java.io.IOException;&#10;import java.io.ObjectInputStream;&#10;import java.io.ObjectOutputStream;&#10;import java.net.ServerSocket;&#10;import java.net.Socket;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;&#10;public class Transport {&#10;&#10;    private int port;&#10;    private volatile boolean running = true;&#10;    private ServerSocket serverSocket;&#10;&#10;    public BlockingQueue&lt;Message&gt; inbox = new LinkedBlockingQueue&lt;&gt;();&#10;&#10;    public Transport(int port) {&#10;        this.port = port;&#10;    }&#10;&#10;    public void start() {&#10;        new Thread(() -&gt; {&#10;            try {&#10;                serverSocket = new ServerSocket(port);&#10;                while (running) {&#10;                    Socket socket = serverSocket.accept();&#10;                    try (ObjectInputStream in = new ObjectInputStream(socket.getInputStream())) {&#10;                        Message msg = (Message)in.readObject();&#10;                        inbox.put(msg);&#10;                    } catch (ClassNotFoundException e) {&#10;                        e.printStackTrace();&#10;                    }&#10;                }&#10;            } catch (IOException | InterruptedException e) {&#10;                if (running) {&#10;                    e.printStackTrace();&#10;                }&#10;            }&#10;        }).start();&#10;    }&#10;&#10;    public void shutdown() {&#10;        running = false;&#10;        if (serverSocket != null &amp;&amp; !serverSocket.isClosed()) {&#10;            try {&#10;                serverSocket.close();&#10;            } catch (IOException e) {&#10;                e.printStackTrace();&#10;            }&#10;        }&#10;    }&#10;&#10;    public void send(String host, int port, Message msg) throws IOException {&#10;        try (Socket socket = new Socket(host, port);&#10;            ObjectOutputStream out = new ObjectOutputStream(socket.getOutputStream())) {&#10;            out.writeObject(msg);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/examples.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/examples.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Helper script with example commands for running the distributed mutual exclusion system&#10;&#10;echo &quot;===================================================&quot;&#10;echo &quot;Distributed Mutual Exclusion - Example Commands&quot;&#10;echo &quot;===================================================&quot;&#10;echo &quot;&quot;&#10;&#10;echo &quot;1. WITHOUT DISTRIBUTED MUTUAL EXCLUSION:&quot;&#10;echo &quot;   Run each command in a separate terminal:&quot;&#10;echo &quot;&quot;&#10;echo &quot;   Terminal 1: ./run_process.sh 1 false&quot;&#10;echo &quot;   Terminal 2: ./run_process.sh 2 false&quot;  &#10;echo &quot;   Terminal 3: ./run_process.sh 3 false&quot;&#10;echo &quot;&quot;&#10;echo &quot;   Expected result: Interleaved writes like |.|.|.||..||.|&quot;&#10;echo &quot;&quot;&#10;&#10;echo &quot;2. WITH DISTRIBUTED MUTUAL EXCLUSION:&quot;&#10;echo &quot;   Run each command in a separate terminal:&quot;&#10;echo &quot;&quot;&#10;echo &quot;   Terminal 1: ./run_process.sh 1 true 2:localhost:8002 3:localhost:8003&quot;&#10;echo &quot;   Terminal 2: ./run_process.sh 2 true 1:localhost:8001 3:localhost:8003&quot;&#10;echo &quot;   Terminal 3: ./run_process.sh 3 true 1:localhost:8001 2:localhost:8002&quot;&#10;echo &quot;&quot;&#10;echo &quot;   Expected result: Clean sequential writes like |.|.|.|.|.|.&quot;&#10;echo &quot;&quot;&#10;&#10;echo &quot;3. MONITORING THE SHARED FILE:&quot;&#10;echo &quot;   In another terminal, run:&quot;&#10;echo &quot;   watch -n 0.5 'cat shared_file.txt | fold -w 80'&quot;&#10;echo &quot;&quot;&#10;&#10;echo &quot;4. FILE LOCATIONS:&quot;&#10;echo &quot;   Script: $(pwd)/run_process.sh&quot;&#10;echo &quot;   Shared file: $(pwd)/shared_file.txt&quot;&#10;echo &quot;   Java classes: $(pwd)/classes/&quot;&#10;echo &quot;&quot;&#10;&#10;echo &quot;===================================================&quot;&#10;echo &quot;Notes:&quot;&#10;echo &quot;- Each process writes a pipe '|' followed by a dot '.'&quot;&#10;echo &quot;- Without DME: You'll see interleaved characters&quot;&#10;echo &quot;- With DME: You'll see clean '|.' pairs&quot;&#10;echo &quot;- Press Ctrl+C to stop any process&quot;&#10;echo &quot;===================================================&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/monitor.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/monitor.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Monitor script to watch the shared file&#10;echo &quot;=== File Monitor ===&quot;&#10;echo &quot;Monitoring shared_file.txt for writes...&quot;&#10;echo &quot;Press Ctrl+C to stop&quot;&#10;echo &quot;&quot;&#10;&#10;# Watch the file and show changes&#10;tail -f shared_file.txt 2&gt;/dev/null &amp;&#10;TAIL_PID=$!&#10;&#10;# Also show periodic stats&#10;while true; do&#10;    if [ -f shared_file.txt ]; then&#10;        size=$(wc -c &lt; shared_file.txt 2&gt;/dev/null || echo &quot;0&quot;)&#10;        echo &quot;[$(date '+%H:%M:%S')] File size: $size characters&quot;&#10;    fi&#10;    sleep 5&#10;done&#10;&#10;# Cleanup on exit&#10;trap &quot;kill $TAIL_PID 2&gt;/dev/null&quot; EXIT" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run-demo.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run-demo.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;&#10;# Compile the Java files&#10;echo &quot;Compiling Java files...&quot;&#10;cd /home/joao/IdeaProjects/distributed-mutual-exclusion&#10;javac -cp . -d . src/main/java/*.java&#10;&#10;if [ $? -eq 0 ]; then&#10;    echo &quot;Compilation successful!&quot;&#10;else&#10;    echo &quot;Compilation failed!&quot;&#10;    exit 1&#10;fi&#10;&#10;echo &quot;&quot;&#10;echo &quot;=== Distributed Mutual Exclusion Demo ===&quot;&#10;echo &quot;&quot;&#10;echo &quot;Available commands:&quot;&#10;echo &quot;  ./run-demo.sh demo     - Show demo instructions&quot;&#10;echo &quot;  ./run-demo.sh clean    - Clean output file&quot;&#10;echo &quot;  ./run-demo.sh dme &lt;id&gt; - Start process with DME (id: 1-3)&quot;&#10;echo &quot;  ./run-demo.sh direct &lt;id&gt; - Start process without DME (id: 1-3)&quot;&#10;echo &quot;&quot;&#10;&#10;if [ $# -eq 0 ]; then&#10;    echo &quot;Usage: ./run-demo.sh &lt;command&gt; [process_id]&quot;&#10;    exit 1&#10;fi&#10;&#10;# Run the appropriate command from project root&#10;cd /home/joao/IdeaProjects/distributed-mutual-exclusion&#10;java -cp . DMEDemo &quot;$@&quot;&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Compile the Java files in their current location&#10;echo &quot;Compiling Java files...&quot;&#10;cd /home/joao/IdeaProjects/distributed-mutual-exclusion/src/main/java&#10;javac *.java&#10;&#10;if [ $? -eq 0 ]; then&#10;    echo &quot;Compilation successful!&quot;&#10;else&#10;    echo &quot;Compilation failed!&quot;&#10;    exit 1&#10;fi&#10;&#10;echo &quot;&quot;&#10;echo &quot;=== Distributed Mutual Exclusion Demo ===&quot;&#10;echo &quot;&quot;&#10;echo &quot;Available commands:&quot;&#10;echo &quot;  ./run-demo.sh demo     - Show demo instructions&quot;&#10;echo &quot;  ./run-demo.sh clean    - Clean output file&quot;&#10;echo &quot;  ./run-demo.sh dme &lt;id&gt; - Start process with DME (id: 1-3)&quot;&#10;echo &quot;  ./run-demo.sh direct &lt;id&gt; - Start process without DME (id: 1-3)&quot;&#10;echo &quot;&quot;&#10;&#10;if [ $# -eq 0 ]; then&#10;    echo &quot;Usage: ./run-demo.sh &lt;command&gt; [process_id]&quot;&#10;    exit 1&#10;fi&#10;&#10;# Run from the source directory using absolute classpath&#10;cd /home/joao/IdeaProjects/distributed-mutual-exclusion&#10;java -cp src/main/java DMEDemo &quot;$@&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_demo.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_demo.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;# Usage: ./run_demo.sh [with-dme|without-dme]&#10;&#10;set -e&#10;&#10;MODE=${1:-with-dme}&#10;OUTPUT_FILE=&quot;output.txt&quot;&#10;&#10;# Clean output file before each run&#10;echo -n &quot;&quot; &gt; &quot;$OUTPUT_FILE&quot;&#10;&#10;# Peer definitions: pid:host:port&#10;PEERS=&quot;1:localhost:5001,2:localhost:5002,3:localhost:5003&quot;&#10;&#10;# Start 3 processes in background&#10;java Main 1 5001 &quot;$PEERS&quot; &quot;$OUTPUT_FILE&quot; &quot;$MODE&quot; &amp;&#10;PID1=$!&#10;java Main 2 5002 &quot;$PEERS&quot; &quot;$OUTPUT_FILE&quot; &quot;$MODE&quot; &amp;&#10;PID2=$!&#10;java Main 3 5003 &quot;$PEERS&quot; &quot;$OUTPUT_FILE&quot; &quot;$MODE&quot; &amp;&#10;PID3=$!&#10;&#10;# Wait for all processes to finish&#10;wait $PID1 $PID2 $PID3&#10;&#10;echo &quot;All processes finished.&quot;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_process.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_process.sh" />
              <option name="originalContent" value="#!/bin/bash&#10;&#10;# Distributed Mutual Exclusion Process Runner&#10;# Usage: ./run_process.sh &lt;process_id&gt; &lt;use_dme&gt; [peer1] [peer2] ...&#10;# Example: ./run_process.sh 1 true 2:localhost:8002 3:localhost:8003&#10;&#10;set -e&#10;&#10;# Configuration&#10;PROJECT_DIR=&quot;/home/joao/IdeaProjects/distributed-mutual-exclusion&quot;&#10;SRC_DIR=&quot;$PROJECT_DIR/src/main/java&quot;&#10;CLASS_DIR=&quot;$PROJECT_DIR/classes&quot;&#10;SHARED_FILE=&quot;$PROJECT_DIR/shared_file.txt&quot;&#10;MAIN_CLASS=&quot;com.dme.FileWriterProcess&quot;&#10;&#10;# Colors for output&#10;RED='\033[0;31m'&#10;GREEN='\033[0;32m'&#10;BLUE='\033[0;34m'&#10;YELLOW='\033[1;33m'&#10;NC='\033[0m' # No Color&#10;&#10;# Function to print colored output&#10;print_info() {&#10;    echo -e &quot;${BLUE}[INFO]${NC} $1&quot;&#10;}&#10;&#10;print_success() {&#10;    echo -e &quot;${GREEN}[SUCCESS]${NC} $1&quot;&#10;}&#10;&#10;print_warning() {&#10;    echo -e &quot;${YELLOW}[WARNING]${NC} $1&quot;&#10;}&#10;&#10;print_error() {&#10;    echo -e &quot;${RED}[ERROR]${NC} $1&quot;&#10;}&#10;&#10;# Function to show usage&#10;show_usage() {&#10;    echo &quot;Usage: $0 &lt;process_id&gt; &lt;use_dme&gt; [peer1] [peer2] ...&quot;&#10;    echo &quot;&quot;&#10;    echo &quot;Parameters:&quot;&#10;    echo &quot;  process_id   : Unique process identifier (1, 2, 3, etc.)&quot;&#10;    echo &quot;  use_dme      : Enable distributed mutual exclusion (true/false)&quot;&#10;    echo &quot;  peers        : Peer processes in format id:host:port&quot;&#10;    echo &quot;&quot;&#10;    echo &quot;Examples:&quot;&#10;    echo &quot;  Without DME: $0 1 false&quot;&#10;    echo &quot;  With DME:    $0 1 true 2:localhost:8002 3:localhost:8003&quot;&#10;    echo &quot;&quot;&#10;    echo &quot;Note: For DME mode, each process listens on port 8000 + process_id&quot;&#10;    echo &quot;      Process 1 -&gt; port 8001, Process 2 -&gt; port 8002, etc.&quot;&#10;}&#10;&#10;# Check arguments&#10;if [ $# -lt 2 ]; then&#10;    print_error &quot;Insufficient arguments&quot;&#10;    show_usage&#10;    exit 1&#10;fi&#10;&#10;PROCESS_ID=$1&#10;USE_DME=$2&#10;shift 2&#10;PEERS=(&quot;$@&quot;)&#10;&#10;# Validate process ID&#10;if ! [[ &quot;$PROCESS_ID&quot; =~ ^[0-9]+$ ]]; then&#10;    print_error &quot;Process ID must be a number&quot;&#10;    exit 1&#10;fi&#10;&#10;# Validate DME flag&#10;if [[ &quot;$USE_DME&quot; != &quot;true&quot; &amp;&amp; &quot;$USE_DME&quot; != &quot;false&quot; ]]; then&#10;    print_error &quot;use_dme must be 'true' or 'false'&quot;&#10;    exit 1&#10;fi&#10;&#10;# Validate peers for DME mode&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    if [ ${#PEERS[@]} -eq 0 ]; then&#10;        print_error &quot;DME mode requires at least one peer&quot;&#10;        show_usage&#10;        exit 1&#10;    fi&#10;&#10;    for peer in &quot;${PEERS[@]}&quot;; do&#10;        if ! [[ &quot;$peer&quot; =~ ^[0-9]+:[a-zA-Z0-9.-]+:[0-9]+$ ]]; then&#10;            print_error &quot;Invalid peer format: $peer&quot;&#10;            print_error &quot;Expected format: id:host:port&quot;&#10;            exit 1&#10;        fi&#10;    done&#10;fi&#10;&#10;print_info &quot;Starting Process $PROCESS_ID with DME=$USE_DME&quot;&#10;&#10;# Step 1: Clean and create directories&#10;print_info &quot;Cleaning and preparing directories...&quot;&#10;cd &quot;$PROJECT_DIR&quot;&#10;rm -rf &quot;$CLASS_DIR&quot;&#10;mkdir -p &quot;$CLASS_DIR&quot;&#10;&#10;# Step 2: Clean shared file&#10;print_info &quot;Cleaning shared file...&quot;&#10;&gt; &quot;$SHARED_FILE&quot;&#10;print_success &quot;Shared file cleaned: $SHARED_FILE&quot;&#10;&#10;# Step 3: Compile Java sources&#10;print_info &quot;Compiling Java sources...&quot;&#10;if ! javac -d &quot;$CLASS_DIR&quot; -cp &quot;$CLASS_DIR&quot; &quot;$SRC_DIR&quot;/com/dme/*.java; then&#10;    print_error &quot;Compilation failed&quot;&#10;    exit 1&#10;fi&#10;print_success &quot;Compilation completed&quot;&#10;&#10;# Step 4: Show configuration&#10;echo &quot;&quot;&#10;print_info &quot;Configuration:&quot;&#10;echo &quot;  Process ID: $PROCESS_ID&quot;&#10;echo &quot;  DME Mode: $USE_DME&quot;&#10;echo &quot;  Listen Port: $((8000 + PROCESS_ID))&quot;&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    echo &quot;  Peers:&quot;&#10;    for peer in &quot;${PEERS[@]}&quot;; do&#10;        echo &quot;    $peer&quot;&#10;    done&#10;fi&#10;echo &quot;  Shared File: $SHARED_FILE&quot;&#10;echo &quot;&quot;&#10;&#10;# Step 5: Wait for user confirmation&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    print_warning &quot;Make sure all peer processes are started before continuing!&quot;&#10;    read -p &quot;Press Enter to start the process...&quot;&#10;fi&#10;&#10;# Step 6: Start the Java process&#10;print_info &quot;Starting FileWriterProcess...&quot;&#10;echo &quot;&quot;&#10;print_success &quot;Process $PROCESS_ID is now running. Press Ctrl+C to stop.&quot;&#10;echo &quot;==========================================&quot;&#10;&#10;cd &quot;$CLASS_DIR&quot;&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    java &quot;$MAIN_CLASS&quot; &quot;$PROCESS_ID&quot; &quot;$USE_DME&quot; &quot;${PEERS[@]}&quot;&#10;else&#10;    java &quot;$MAIN_CLASS&quot; &quot;$PROCESS_ID&quot; &quot;$USE_DME&quot;&#10;fi&#10;" />
              <option name="updatedContent" value="#!/bin/bash&#10;&#10;# Distributed Mutual Exclusion Process Runner&#10;# Usage: ./run_process.sh &lt;process_id&gt; &lt;use_dme&gt; [peer1] [peer2] ...&#10;# Example: ./run_process.sh 1 true 2:localhost:8002 3:localhost:8003&#10;&#10;set -e&#10;&#10;# Configuration&#10;PROJECT_DIR=&quot;/home/joao/IdeaProjects/distributed-mutual-exclusion&quot;&#10;SRC_DIR=&quot;$PROJECT_DIR/src/main/java&quot;&#10;CLASS_DIR=&quot;$PROJECT_DIR/classes&quot;&#10;SHARED_FILE=&quot;$PROJECT_DIR/shared_file.txt&quot;&#10;MAIN_CLASS=&quot;com.dme.FileWriterProcess&quot;&#10;&#10;# Colors for output&#10;RED='\033[0;31m'&#10;GREEN='\033[0;32m'&#10;BLUE='\033[0;34m'&#10;YELLOW='\033[1;33m'&#10;NC='\033[0m' # No Color&#10;&#10;# Function to print colored output&#10;print_info() {&#10;    echo -e &quot;${BLUE}[INFO]${NC} $1&quot;&#10;}&#10;&#10;print_success() {&#10;    echo -e &quot;${GREEN}[SUCCESS]${NC} $1&quot;&#10;}&#10;&#10;print_warning() {&#10;    echo -e &quot;${YELLOW}[WARNING]${NC} $1&quot;&#10;}&#10;&#10;print_error() {&#10;    echo -e &quot;${RED}[ERROR]${NC} $1&quot;&#10;}&#10;&#10;# Function to show usage&#10;show_usage() {&#10;    echo &quot;Usage: $0 &lt;process_id&gt; &lt;use_dme&gt; [peer1] [peer2] ...&quot;&#10;    echo &quot;&quot;&#10;    echo &quot;Parameters:&quot;&#10;    echo &quot;  process_id   : Unique process identifier (1, 2, 3, etc.)&quot;&#10;    echo &quot;  use_dme      : Enable distributed mutual exclusion (true/false)&quot;&#10;    echo &quot;  peers        : Peer processes in format id:host:port&quot;&#10;    echo &quot;&quot;&#10;    echo &quot;Examples:&quot;&#10;    echo &quot;  Without DME: $0 1 false&quot;&#10;    echo &quot;  With DME:    $0 1 true 2:localhost:8002 3:localhost:8003&quot;&#10;    echo &quot;&quot;&#10;    echo &quot;Note: For DME mode, each process listens on port 8000 + process_id&quot;&#10;    echo &quot;      Process 1 -&gt; port 8001, Process 2 -&gt; port 8002, etc.&quot;&#10;}&#10;&#10;# Check arguments&#10;if [ $# -lt 2 ]; then&#10;    print_error &quot;Insufficient arguments&quot;&#10;    show_usage&#10;    exit 1&#10;fi&#10;&#10;PROCESS_ID=$1&#10;USE_DME=$2&#10;shift 2&#10;PEERS=(&quot;$@&quot;)&#10;&#10;# Validate process ID&#10;if ! [[ &quot;$PROCESS_ID&quot; =~ ^[0-9]+$ ]]; then&#10;    print_error &quot;Process ID must be a number&quot;&#10;    exit 1&#10;fi&#10;&#10;# Validate DME flag&#10;if [[ &quot;$USE_DME&quot; != &quot;true&quot; &amp;&amp; &quot;$USE_DME&quot; != &quot;false&quot; ]]; then&#10;    print_error &quot;use_dme must be 'true' or 'false'&quot;&#10;    exit 1&#10;fi&#10;&#10;# Validate peers for DME mode&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    if [ ${#PEERS[@]} -eq 0 ]; then&#10;        print_error &quot;DME mode requires at least one peer&quot;&#10;        show_usage&#10;        exit 1&#10;    fi&#10;&#10;    for peer in &quot;${PEERS[@]}&quot;; do&#10;        if ! [[ &quot;$peer&quot; =~ ^[0-9]+:[a-zA-Z0-9.-]+:[0-9]+$ ]]; then&#10;            print_error &quot;Invalid peer format: $peer&quot;&#10;            print_error &quot;Expected format: id:host:port&quot;&#10;            exit 1&#10;        fi&#10;    done&#10;fi&#10;&#10;print_info &quot;Starting Process $PROCESS_ID with DME=$USE_DME&quot;&#10;&#10;# Step 1: Clean and create directories&#10;print_info &quot;Cleaning and preparing directories...&quot;&#10;cd &quot;$PROJECT_DIR&quot;&#10;rm -rf &quot;$CLASS_DIR&quot;&#10;mkdir -p &quot;$CLASS_DIR&quot;&#10;&#10;# Step 2: Clean shared file (only for process 1 or when explicitly requested)&#10;if [[ &quot;$PROCESS_ID&quot; == &quot;1&quot; ]]; then&#10;    print_info &quot;Cleaning shared file (Process 1)...&quot;&#10;    &gt; &quot;$SHARED_FILE&quot;&#10;    print_success &quot;Shared file cleaned: $SHARED_FILE&quot;&#10;else&#10;    print_info &quot;Skipping file cleaning (not Process 1)...&quot;&#10;    # Ensure file exists&#10;    touch &quot;$SHARED_FILE&quot;&#10;fi&#10;&#10;# Step 3: Compile Java sources&#10;print_info &quot;Compiling Java sources...&quot;&#10;if ! javac -d &quot;$CLASS_DIR&quot; -cp &quot;$CLASS_DIR&quot; &quot;$SRC_DIR&quot;/com/dme/*.java; then&#10;    print_error &quot;Compilation failed&quot;&#10;    exit 1&#10;fi&#10;print_success &quot;Compilation completed&quot;&#10;&#10;# Step 4: Show configuration&#10;echo &quot;&quot;&#10;print_info &quot;Configuration:&quot;&#10;echo &quot;  Process ID: $PROCESS_ID&quot;&#10;echo &quot;  DME Mode: $USE_DME&quot;&#10;echo &quot;  Listen Port: $((8000 + PROCESS_ID))&quot;&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    echo &quot;  Peers:&quot;&#10;    for peer in &quot;${PEERS[@]}&quot;; do&#10;        echo &quot;    $peer&quot;&#10;    done&#10;fi&#10;echo &quot;  Shared File: $SHARED_FILE&quot;&#10;echo &quot;&quot;&#10;&#10;# Step 5: Wait for user confirmation&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    print_warning &quot;Make sure all peer processes are started before continuing!&quot;&#10;    read -p &quot;Press Enter to start the process...&quot;&#10;fi&#10;&#10;# Step 6: Start the Java process&#10;print_info &quot;Starting FileWriterProcess...&quot;&#10;echo &quot;&quot;&#10;print_success &quot;Process $PROCESS_ID is now running. Press Ctrl+C to stop.&quot;&#10;echo &quot;==========================================&quot;&#10;&#10;cd &quot;$CLASS_DIR&quot;&#10;if [[ &quot;$USE_DME&quot; == &quot;true&quot; ]]; then&#10;    java &quot;$MAIN_CLASS&quot; &quot;$PROCESS_ID&quot; &quot;$USE_DME&quot; &quot;${PEERS[@]}&quot;&#10;else&#10;    java &quot;$MAIN_CLASS&quot; &quot;$PROCESS_ID&quot; &quot;$USE_DME&quot;&#10;fi" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_with_dme.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_with_dme.sh" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/run_without_dme.sh">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/run_without_dme.sh" />
              <option name="updatedContent" value="#!/bin/bash&#10;# Wait for all processes to complete&#10;wait $PID1&#10;wait $PID2&#10;wait $PID3&#10;&#10;echo &quot;&quot;&#10;echo &quot;All processes completed. Output file contents:&quot;&#10;echo &quot;==============================================&quot;&#10;cat output.txt&#10;echo &quot;&quot;&#10;echo &quot;==============================================&quot;&#10;echo &quot;Without DME, you should see interleaved/random patterns like ||..|.. etc.&quot;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/DMEDemo.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/DMEDemo.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/FileWriter.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/FileWriter.java" />
              <option name="updatedContent" value="import java.io.FileOutputStream;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;&#10;public class FileWriter {&#10;    private static final String OUTPUT_FILE = &quot;output.txt&quot;;&#10;    private volatile boolean running = true;&#10;    &#10;    public static void main(String[] args) {&#10;        FileWriter writer = new FileWriter();&#10;        &#10;        // Add shutdown hook to gracefully stop the process&#10;        Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;            System.out.println(&quot;\nShutting down gracefully...&quot;);&#10;            writer.stop();&#10;        }));&#10;        &#10;        writer.start();&#10;    }&#10;    &#10;    public void start() {&#10;        System.out.println(&quot;Starting continuous file writer...&quot;);&#10;        System.out.println(&quot;Writing to file: &quot; + OUTPUT_FILE);&#10;        System.out.println(&quot;Press Ctrl+C to stop&quot;);&#10;        &#10;        try {&#10;            // Create the file if it doesn't exist&#10;            Path filePath = Paths.get(OUTPUT_FILE);&#10;            if (!Files.exists(filePath)) {&#10;                Files.createFile(filePath);&#10;            }&#10;            &#10;            try (FileOutputStream fos = new FileOutputStream(OUTPUT_FILE, true)) {&#10;                while (running) {&#10;                    // First write: pipe &quot;|&quot;&#10;                    fos.write('|');&#10;                    fos.flush();&#10;                    System.out.print(&quot;|&quot;);&#10;                    &#10;                    // Small delay to make the sequential nature visible&#10;                    Thread.sleep(100);&#10;                    &#10;                    // Second write: dot &quot;.&quot;&#10;                    fos.write('.');&#10;                    fos.flush();&#10;                    System.out.print(&quot;.&quot;);&#10;                    &#10;                    // Delay before next iteration&#10;                    Thread.sleep(500);&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error writing to file: &quot; + e.getMessage());&#10;        } catch (InterruptedException e) {&#10;            System.out.println(&quot;Process interrupted&quot;);&#10;            Thread.currentThread().interrupt();&#10;        }&#10;        &#10;        System.out.println(&quot;\nFile writer stopped.&quot;);&#10;    }&#10;    &#10;    public void stop() {&#10;        running = false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/LamportClock.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/LamportClock.java" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/LamportProcess.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/LamportProcess.java" />
              <option name="originalContent" value="import java.io.*;&#10;import java.net.*;&#10;import java.util.*;&#10;import java.util.concurrent.*;&#10;&#10;/**&#10; * Implementation of Lamport's Distributed Mutual Exclusion Algorithm&#10; */&#10;public class LamportProcess {&#10;    private final int processId;&#10;    private final int port;&#10;    private final List&lt;Integer&gt; otherPorts;&#10;    private int logicalClock;&#10;    private final PriorityQueue&lt;Request&gt; requestQueue;&#10;    private final Set&lt;Integer&gt; acknowledgedBy;&#10;    private boolean inCriticalSection;&#10;    private final boolean useDME;&#10;    private final String outputFile;&#10;&#10;    // Network components&#10;    private ServerSocket serverSocket;&#10;    private final ExecutorService executor;&#10;&#10;    public LamportProcess(int processId, int port, List&lt;Integer&gt; otherPorts, boolean useDME, String outputFile) {&#10;        this.processId = processId;&#10;        this.port = port;&#10;        this.otherPorts = new ArrayList&lt;&gt;(otherPorts);&#10;        this.logicalClock = 0;&#10;        this.requestQueue = new PriorityQueue&lt;&gt;();&#10;        this.acknowledgedBy = new HashSet&lt;&gt;();&#10;        this.inCriticalSection = false;&#10;        this.useDME = useDME;&#10;        this.outputFile = outputFile;&#10;        this.executor = Executors.newCachedThreadPool();&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        // Start server to listen for messages&#10;        serverSocket = new ServerSocket(port);&#10;        executor.submit(this::listenForMessages);&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; started on port &quot; + port +&#10;                          &quot; (DME: &quot; + (useDME ? &quot;enabled&quot; : &quot;disabled&quot;) + &quot;)&quot;);&#10;&#10;        // Wait a bit for all processes to start&#10;        try {&#10;            Thread.sleep(2000);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;&#10;        // Start requesting critical section access&#10;        executor.submit(this::requestCriticalSectionPeriodically);&#10;    }&#10;&#10;    private void listenForMessages() {&#10;        while (!Thread.currentThread().isInterrupted()) {&#10;            try {&#10;                Socket clientSocket = serverSocket.accept();&#10;                executor.submit(() -&gt; handleMessage(clientSocket));&#10;            } catch (IOException e) {&#10;                if (!serverSocket.isClosed()) {&#10;                    System.err.println(&quot;Process &quot; + processId + &quot; error accepting connection: &quot; + e.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleMessage(Socket clientSocket) {&#10;        try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));&#10;             PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {&#10;&#10;            String message = reader.readLine();&#10;            if (message != null) {&#10;                String[] parts = message.split(&quot;:&quot;);&#10;                String messageType = parts[0];&#10;                int senderClock = Integer.parseInt(parts[1]);&#10;                int senderId = Integer.parseInt(parts[2]);&#10;&#10;                // Update logical clock&#10;                synchronized (this) {&#10;                    logicalClock = Math.max(logicalClock, senderClock) + 1;&#10;                }&#10;&#10;                switch (messageType) {&#10;                    case &quot;REQUEST&quot;:&#10;                        handleRequestMessage(senderId, senderClock);&#10;                        writer.println(&quot;ACK:&quot; + logicalClock + &quot;:&quot; + processId);&#10;                        break;&#10;                    case &quot;ACK&quot;:&#10;                        handleAckMessage(senderId);&#10;                        break;&#10;                    case &quot;RELEASE&quot;:&#10;                        handleReleaseMessage(senderId, senderClock);&#10;                        break;&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Process &quot; + processId + &quot; error handling message: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private synchronized void handleRequestMessage(int senderId, int senderClock) {&#10;        requestQueue.offer(new Request(senderId, senderClock));&#10;        System.out.println(&quot;Process &quot; + processId + &quot; received REQUEST from &quot; + senderId + &quot; at clock &quot; + senderClock);&#10;    }&#10;&#10;    private synchronized void handleAckMessage(int senderId) {&#10;        acknowledgedBy.add(senderId);&#10;        System.out.println(&quot;Process &quot; + processId + &quot; received ACK from &quot; + senderId +&#10;                          &quot; (total ACKs: &quot; + acknowledgedBy.size() + &quot;/&quot; + otherPorts.size() + &quot;)&quot;);&#10;&#10;        // Check if we can enter critical section&#10;        if (canEnterCriticalSection()) {&#10;            enterCriticalSection();&#10;        }&#10;    }&#10;&#10;    private synchronized void handleReleaseMessage(int senderId, int senderClock) {&#10;        requestQueue.removeIf(req -&gt; req.processId == senderId);&#10;        System.out.println(&quot;Process &quot; + processId + &quot; received RELEASE from &quot; + senderId);&#10;&#10;        // Check if we can now enter critical section&#10;        if (canEnterCriticalSection()) {&#10;            enterCriticalSection();&#10;        }&#10;    }&#10;&#10;    private void requestCriticalSectionPeriodically() {&#10;        Random random = new Random();&#10;        while (!Thread.currentThread().isInterrupted()) {&#10;            try {&#10;                // Wait random time between requests&#10;                Thread.sleep(1000 + random.nextInt(3000));&#10;&#10;                if (useDME) {&#10;                    requestCriticalSectionWithDME();&#10;                } else {&#10;                    accessFileDirectly();&#10;                }&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private synchronized void requestCriticalSectionWithDME() {&#10;        if (inCriticalSection) {&#10;            return;&#10;        }&#10;&#10;        logicalClock++;&#10;        Request myRequest = new Request(processId, logicalClock);&#10;        requestQueue.offer(myRequest);&#10;        acknowledgedBy.clear();&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; requesting critical section at clock &quot; + logicalClock);&#10;&#10;        // Send REQUEST to all other processes&#10;        for (int otherPort : otherPorts) {&#10;            sendMessage(otherPort, &quot;REQUEST:&quot; + logicalClock + &quot;:&quot; + processId);&#10;        }&#10;    }&#10;&#10;    private synchronized boolean canEnterCriticalSection() {&#10;        if (inCriticalSection || requestQueue.isEmpty()) {&#10;            return false;&#10;        }&#10;&#10;        Request firstRequest = requestQueue.peek();&#10;        if (firstRequest.processId != processId) {&#10;            return false;&#10;        }&#10;&#10;        // Check if we have ACKs from all other processes&#10;        return acknowledgedBy.size() == otherPorts.size();&#10;    }&#10;&#10;    private synchronized void enterCriticalSection() {&#10;        if (inCriticalSection) {&#10;            return;&#10;        }&#10;&#10;        inCriticalSection = true;&#10;        requestQueue.poll(); // Remove our request&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; ENTERING critical section&quot;);&#10;&#10;        // Access the file&#10;        accessFile();&#10;&#10;        // Exit critical section&#10;        exitCriticalSection();&#10;    }&#10;&#10;    private synchronized void exitCriticalSection() {&#10;        inCriticalSection = false;&#10;        logicalClock++;&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; EXITING critical section&quot;);&#10;&#10;        // Send RELEASE to all other processes&#10;        for (int otherPort : otherPorts) {&#10;            sendMessage(otherPort, &quot;RELEASE:&quot; + logicalClock + &quot;:&quot; + processId);&#10;        }&#10;    }&#10;&#10;    private void accessFile() {&#10;        try {&#10;            // Write pipe character&#10;            writeToFile(&quot;|&quot;);&#10;            Thread.sleep(100); // Simulate some processing time&#10;&#10;            // Write dot character&#10;            writeToFile(&quot;.&quot;);&#10;            Thread.sleep(100);&#10;&#10;            System.out.println(&quot;Process &quot; + processId + &quot; wrote |. to file&quot;);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;&#10;    private void accessFileDirectly() {&#10;        System.out.println(&quot;Process &quot; + processId + &quot; accessing file directly (no DME)&quot;);&#10;        try {&#10;            // Write pipe character&#10;            writeToFile(&quot;|&quot;);&#10;            Thread.sleep(50 + new Random().nextInt(100)); // Random delay&#10;&#10;            // Write dot character&#10;            writeToFile(&quot;.&quot;);&#10;            Thread.sleep(50 + new Random().nextInt(100));&#10;&#10;            System.out.println(&quot;Process &quot; + processId + &quot; wrote |. to file (direct access)&quot;);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;&#10;    private synchronized void writeToFile(String content) {&#10;        try (FileWriter writer = new FileWriter(outputFile, true)) {&#10;            writer.write(content);&#10;            writer.flush();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Process &quot; + processId + &quot; error writing to file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void sendMessage(int targetPort, String message) {&#10;        try (Socket socket = new Socket(&quot;localhost&quot;, targetPort);&#10;             PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);&#10;             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {&#10;&#10;            writer.println(message);&#10;&#10;            // Read response if it's a REQUEST (expecting ACK)&#10;            if (message.startsWith(&quot;REQUEST&quot;)) {&#10;                String response = reader.readLine();&#10;                if (response != null &amp;&amp; response.startsWith(&quot;ACK&quot;)) {&#10;                    String[] parts = response.split(&quot;:&quot;);&#10;                    int senderClock = Integer.parseInt(parts[1]);&#10;                    int senderId = Integer.parseInt(parts[2]);&#10;&#10;                    synchronized (this) {&#10;                        logicalClock = Math.max(logicalClock, senderClock) + 1;&#10;                        acknowledgedBy.add(senderId);&#10;                    }&#10;&#10;                    System.out.println(&quot;Process &quot; + processId + &quot; received ACK from &quot; + senderId);&#10;&#10;                    // Check if we can enter critical section&#10;                    if (canEnterCriticalSection()) {&#10;                        enterCriticalSection();&#10;                    }&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            // Ignore connection errors (other process might not be ready yet)&#10;        }&#10;    }&#10;&#10;    public void shutdown() {&#10;        try {&#10;            executor.shutdown();&#10;            if (serverSocket != null &amp;&amp; !serverSocket.isClosed()) {&#10;                serverSocket.close();&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error shutting down process &quot; + processId + &quot;: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static class Request implements Comparable&lt;Request&gt; {&#10;        final int processId;&#10;        final int timestamp;&#10;&#10;        Request(int processId, int timestamp) {&#10;            this.processId = processId;&#10;            this.timestamp = timestamp;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(Request other) {&#10;            if (this.timestamp != other.timestamp) {&#10;                return Integer.compare(this.timestamp, other.timestamp);&#10;            }&#10;            return Integer.compare(this.processId, other.processId);&#10;        }&#10;&#10;        @Override&#10;        public boolean equals(Object obj) {&#10;            if (this == obj) return true;&#10;            if (obj == null || getClass() != obj.getClass()) return false;&#10;            Request request = (Request) obj;&#10;            return processId == request.processId &amp;&amp; timestamp == request.timestamp;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            return Objects.hash(processId, timestamp);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="import java.io.*;&#10;import java.net.*;&#10;import java.util.*;&#10;import java.util.concurrent.*;&#10;&#10;/**&#10; * Implementation of Lamport's Distributed Mutual Exclusion Algorithm&#10; */&#10;public class LamportProcess {&#10;    private final int processId;&#10;    private final int port;&#10;    private final List&lt;Integer&gt; otherPorts;&#10;    private int logicalClock;&#10;    private final PriorityQueue&lt;Request&gt; requestQueue;&#10;    private final Set&lt;Integer&gt; acknowledgedBy;&#10;    private boolean inCriticalSection;&#10;    private final boolean useDME;&#10;    private final String outputFile;&#10;&#10;    // Network components&#10;    private ServerSocket serverSocket;&#10;    private final ExecutorService executor;&#10;&#10;    public LamportProcess(int processId, int port, List&lt;Integer&gt; otherPorts, boolean useDME, String outputFile) {&#10;        this.processId = processId;&#10;        this.port = port;&#10;        this.otherPorts = new ArrayList&lt;&gt;(otherPorts);&#10;        this.logicalClock = 0;&#10;        this.requestQueue = new PriorityQueue&lt;&gt;();&#10;        this.acknowledgedBy = new HashSet&lt;&gt;();&#10;        this.inCriticalSection = false;&#10;        this.useDME = useDME;&#10;        this.outputFile = outputFile;&#10;        this.executor = Executors.newCachedThreadPool();&#10;    }&#10;&#10;    public void start() throws IOException {&#10;        // Start server to listen for messages&#10;        serverSocket = new ServerSocket(port);&#10;        executor.submit(this::listenForMessages);&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; started on port &quot; + port +&#10;                          &quot; (DME: &quot; + (useDME ? &quot;enabled&quot; : &quot;disabled&quot;) + &quot;)&quot;);&#10;&#10;        // Wait a bit for all processes to start&#10;        try {&#10;            Thread.sleep(2000);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;&#10;        // Start requesting critical section access&#10;        executor.submit(this::requestCriticalSectionPeriodically);&#10;    }&#10;&#10;    private void listenForMessages() {&#10;        while (!Thread.currentThread().isInterrupted()) {&#10;            try {&#10;                Socket clientSocket = serverSocket.accept();&#10;                executor.submit(() -&gt; handleMessage(clientSocket));&#10;            } catch (IOException e) {&#10;                if (!serverSocket.isClosed()) {&#10;                    System.err.println(&quot;Process &quot; + processId + &quot; error accepting connection: &quot; + e.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private void handleMessage(Socket clientSocket) {&#10;        try (BufferedReader reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));&#10;             PrintWriter writer = new PrintWriter(clientSocket.getOutputStream(), true)) {&#10;&#10;            String message = reader.readLine();&#10;            if (message != null) {&#10;                String[] parts = message.split(&quot;:&quot;);&#10;                String messageType = parts[0];&#10;                int senderClock = Integer.parseInt(parts[1]);&#10;                int senderId = Integer.parseInt(parts[2]);&#10;&#10;                // Update logical clock&#10;                logicalClock = Math.max(logicalClock, senderClock) + 1;&#10;&#10;                switch (messageType) {&#10;                    case &quot;REQUEST&quot;:&#10;                        handleRequestMessage(senderId, senderClock);&#10;                        writer.println(&quot;ACK:&quot; + logicalClock + &quot;:&quot; + processId);&#10;                        break;&#10;                    case &quot;ACK&quot;:&#10;                        handleAckMessage(senderId);&#10;                        break;&#10;                    case &quot;RELEASE&quot;:&#10;                        handleReleaseMessage(senderId, senderClock);&#10;                        break;&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Process &quot; + processId + &quot; error handling message: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void handleRequestMessage(int senderId, int senderClock) {&#10;        requestQueue.offer(new Request(senderId, senderClock));&#10;        System.out.println(&quot;Process &quot; + processId + &quot; received REQUEST from &quot; + senderId + &quot; at clock &quot; + senderClock);&#10;    }&#10;&#10;    private void handleAckMessage(int senderId) {&#10;        acknowledgedBy.add(senderId);&#10;        System.out.println(&quot;Process &quot; + processId + &quot; received ACK from &quot; + senderId +&#10;                          &quot; (total ACKs: &quot; + acknowledgedBy.size() + &quot;/&quot; + otherPorts.size() + &quot;)&quot;);&#10;&#10;        // Check if we can enter critical section&#10;        if (canEnterCriticalSection()) {&#10;            enterCriticalSection();&#10;        }&#10;    }&#10;&#10;    private void handleReleaseMessage(int senderId, int senderClock) {&#10;        requestQueue.removeIf(req -&gt; req.processId == senderId);&#10;        System.out.println(&quot;Process &quot; + processId + &quot; received RELEASE from &quot; + senderId);&#10;&#10;        // Check if we can now enter critical section&#10;        if (canEnterCriticalSection()) {&#10;            enterCriticalSection();&#10;        }&#10;    }&#10;&#10;    private void requestCriticalSectionPeriodically() {&#10;        Random random = new Random();&#10;        while (!Thread.currentThread().isInterrupted()) {&#10;            try {&#10;                // Wait random time between requests&#10;                Thread.sleep(1000 + random.nextInt(3000));&#10;&#10;                if (useDME) {&#10;                    requestCriticalSectionWithDME();&#10;                } else {&#10;                    accessFileDirectly();&#10;                }&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private void requestCriticalSectionWithDME() {&#10;        if (inCriticalSection) {&#10;            return;&#10;        }&#10;&#10;        logicalClock++;&#10;        Request myRequest = new Request(processId, logicalClock);&#10;        requestQueue.offer(myRequest);&#10;        acknowledgedBy.clear();&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; requesting critical section at clock &quot; + logicalClock);&#10;&#10;        // Send REQUEST to all other processes&#10;        for (int otherPort : otherPorts) {&#10;            sendMessage(otherPort, &quot;REQUEST:&quot; + logicalClock + &quot;:&quot; + processId);&#10;        }&#10;    }&#10;&#10;    private boolean canEnterCriticalSection() {&#10;        if (inCriticalSection || requestQueue.isEmpty()) {&#10;            return false;&#10;        }&#10;&#10;        Request firstRequest = requestQueue.peek();&#10;        if (firstRequest.processId != processId) {&#10;            return false;&#10;        }&#10;&#10;        // Check if we have ACKs from all other processes&#10;        return acknowledgedBy.size() == otherPorts.size();&#10;    }&#10;&#10;    private void enterCriticalSection() {&#10;        if (inCriticalSection) {&#10;            return;&#10;        }&#10;&#10;        inCriticalSection = true;&#10;        requestQueue.poll(); // Remove our request&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; ENTERING critical section&quot;);&#10;&#10;        // Access the file&#10;        accessFile();&#10;&#10;        // Exit critical section&#10;        exitCriticalSection();&#10;    }&#10;&#10;    private void exitCriticalSection() {&#10;        inCriticalSection = false;&#10;        logicalClock++;&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; EXITING critical section&quot;);&#10;&#10;        // Send RELEASE to all other processes&#10;        for (int otherPort : otherPorts) {&#10;            sendMessage(otherPort, &quot;RELEASE:&quot; + logicalClock + &quot;:&quot; + processId);&#10;        }&#10;    }&#10;&#10;    private void accessFile() {&#10;        try {&#10;            // Write pipe character&#10;            writeToFile(&quot;|&quot;);&#10;            Thread.sleep(100); // Simulate some processing time&#10;&#10;            // Write dot character&#10;            writeToFile(&quot;.&quot;);&#10;            Thread.sleep(100);&#10;&#10;            System.out.println(&quot;Process &quot; + processId + &quot; wrote |. to file&quot;);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;&#10;    private void accessFileDirectly() {&#10;        System.out.println(&quot;Process &quot; + processId + &quot; accessing file directly (no DME)&quot;);&#10;        try {&#10;            // Write pipe character&#10;            writeToFile(&quot;|&quot;);&#10;            Thread.sleep(50 + new Random().nextInt(100)); // Random delay&#10;&#10;            // Write dot character&#10;            writeToFile(&quot;.&quot;);&#10;            Thread.sleep(50 + new Random().nextInt(100));&#10;&#10;            System.out.println(&quot;Process &quot; + processId + &quot; wrote |. to file (direct access)&quot;);&#10;        } catch (InterruptedException e) {&#10;            Thread.currentThread().interrupt();&#10;        }&#10;    }&#10;&#10;    private void writeToFile(String content) {&#10;        try (FileWriter writer = new FileWriter(outputFile, true)) {&#10;            writer.write(content);&#10;            writer.flush();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Process &quot; + processId + &quot; error writing to file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void sendMessage(int targetPort, String message) {&#10;        try (Socket socket = new Socket(&quot;localhost&quot;, targetPort);&#10;             PrintWriter writer = new PrintWriter(socket.getOutputStream(), true);&#10;             BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()))) {&#10;&#10;            writer.println(message);&#10;&#10;            // Read response if it's a REQUEST (expecting ACK)&#10;            if (message.startsWith(&quot;REQUEST&quot;)) {&#10;                String response = reader.readLine();&#10;                if (response != null &amp;&amp; response.startsWith(&quot;ACK&quot;)) {&#10;                    String[] parts = response.split(&quot;:&quot;);&#10;                    int senderClock = Integer.parseInt(parts[1]);&#10;                    int senderId = Integer.parseInt(parts[2]);&#10;&#10;                    logicalClock = Math.max(logicalClock, senderClock) + 1;&#10;                    acknowledgedBy.add(senderId);&#10;&#10;                    System.out.println(&quot;Process &quot; + processId + &quot; received ACK from &quot; + senderId);&#10;&#10;                    // Check if we can enter critical section&#10;                    if (canEnterCriticalSection()) {&#10;                        enterCriticalSection();&#10;                    }&#10;                }&#10;            }&#10;        } catch (IOException e) {&#10;            // Ignore connection errors (other process might not be ready yet)&#10;        }&#10;    }&#10;&#10;    public void shutdown() {&#10;        try {&#10;            executor.shutdown();&#10;            if (serverSocket != null &amp;&amp; !serverSocket.isClosed()) {&#10;                serverSocket.close();&#10;            }&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error shutting down process &quot; + processId + &quot;: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private static class Request implements Comparable&lt;Request&gt; {&#10;        final int processId;&#10;        final int timestamp;&#10;&#10;        Request(int processId, int timestamp) {&#10;            this.processId = processId;&#10;            this.timestamp = timestamp;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(Request other) {&#10;            if (this.timestamp != other.timestamp) {&#10;                return Integer.compare(this.timestamp, other.timestamp);&#10;            }&#10;            return Integer.compare(this.processId, other.processId);&#10;        }&#10;&#10;        @Override&#10;        public boolean equals(Object obj) {&#10;            if (this == obj) return true;&#10;            if (obj == null || getClass() != obj.getClass()) return false;&#10;            Request request = (Request) obj;&#10;            return processId == request.processId &amp;&amp; timestamp == request.timestamp;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            return Objects.hash(processId, timestamp);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Process.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Process.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/Request.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/Request.java" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/DMEProcess.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/DMEProcess.java" />
              <option name="updatedContent" value="package com.dme;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/DistributedMutualExclusion.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/DistributedMutualExclusion.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.dme;&#10;&#10;import java.util.*;&#10;&#10;public class DistributedMutualExclusion {&#10;    private final int processId;&#10;    private final com.dme.LamportClock clock;&#10;    private final com.dme.NetworkHandler networkHandler;&#10;    private final List&lt;ProcessInfo&gt; peers;&#10;    private final PriorityQueue&lt;RequestInfo&gt; requestQueue;&#10;    private final Set&lt;Integer&gt; replySet;&#10;    private boolean requestingCS = false;&#10;    private int myRequestTimestamp = -1;&#10;&#10;    public static class ProcessInfo {&#10;        public final int id;&#10;        public final String host;&#10;        public final int port;&#10;&#10;        public ProcessInfo(int id, String host, int port) {&#10;            this.id = id;&#10;            this.host = host;&#10;            this.port = port;&#10;        }&#10;    }&#10;&#10;    private static class RequestInfo implements Comparable&lt;RequestInfo&gt; {&#10;        public final int timestamp;&#10;        public final int processId;&#10;&#10;        public RequestInfo(int timestamp, int processId) {&#10;            this.timestamp = timestamp;&#10;            this.processId = processId;&#10;        }&#10;&#10;        @Override&#10;        public int compareTo(RequestInfo other) {&#10;            if (this.timestamp != other.timestamp) {&#10;                return Integer.compare(this.timestamp, other.timestamp);&#10;            }&#10;            return Integer.compare(this.processId, other.processId);&#10;        }&#10;&#10;        @Override&#10;        public boolean equals(Object obj) {&#10;            if (this == obj) return true;&#10;            if (!(obj instanceof RequestInfo)) return false;&#10;            RequestInfo other = (RequestInfo) obj;&#10;            return timestamp == other.timestamp &amp;&amp; processId == other.processId;&#10;        }&#10;&#10;        @Override&#10;        public int hashCode() {&#10;            return Objects.hash(timestamp, processId);&#10;        }&#10;    }&#10;&#10;    public DistributedMutualExclusion(int processId, int port, List&lt;ProcessInfo&gt; peers) {&#10;        this.processId = processId;&#10;        this.clock = new com.dme.LamportClock();&#10;        this.networkHandler = new com.dme.NetworkHandler(port);&#10;        this.peers = new ArrayList&lt;&gt;(peers);&#10;        this.requestQueue = new PriorityQueue&lt;&gt;();&#10;        this.replySet = new HashSet&lt;&gt;();&#10;    }&#10;&#10;    public void start() throws Exception {&#10;        networkHandler.start();&#10;&#10;        // Start message processing thread&#10;        new Thread(this::processMessages).start();&#10;&#10;        System.out.println(&quot;DME Process &quot; + processId + &quot; started&quot;);&#10;    }&#10;&#10;    private void processMessages() {&#10;        while (true) {&#10;            try {&#10;                com.dme.LamportMessage message = networkHandler.receiveMessage();&#10;                handleMessage(message);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                break;&#10;            }&#10;        }&#10;    }&#10;&#10;    private synchronized void handleMessage(com.dme.LamportMessage message) {&#10;        clock.update(message.getTimestamp());&#10;&#10;        switch (message.getType()) {&#10;            case REQUEST:&#10;                handleRequest(message);&#10;                break;&#10;            case REPLY:&#10;                handleReply(message);&#10;                break;&#10;            case RELEASE:&#10;                handleRelease(message);&#10;                break;&#10;        }&#10;    }&#10;&#10;    private void handleRequest(com.dme.LamportMessage message) {&#10;        requestQueue.add(new RequestInfo(message.getTimestamp(), message.getProcessId()));&#10;&#10;        // Send reply&#10;        com.dme.LamportMessage reply = new com.dme.LamportMessage(&#10;            com.dme.LamportMessage.Type.REPLY,&#10;            clock.tick(),&#10;            processId&#10;        );&#10;&#10;        ProcessInfo sender = findPeer(message.getProcessId());&#10;        if (sender != null) {&#10;            networkHandler.sendMessage(sender.host, sender.port, reply);&#10;        }&#10;    }&#10;&#10;    private void handleReply(com.dme.LamportMessage message) {&#10;        replySet.add(message.getProcessId());&#10;        checkCriticalSectionEntry();&#10;    }&#10;&#10;    private void handleRelease(com.dme.LamportMessage message) {&#10;        requestQueue.removeIf(req -&gt; req.processId == message.getProcessId());&#10;        checkCriticalSectionEntry();&#10;    }&#10;&#10;    public synchronized void requestCriticalSection() {&#10;        requestingCS = true;&#10;        myRequestTimestamp = clock.tick();&#10;        replySet.clear();&#10;&#10;        // Add own request to queue&#10;        requestQueue.add(new RequestInfo(myRequestTimestamp, processId));&#10;&#10;        // Send request to all peers&#10;        com.dme.LamportMessage request = new com.dme.LamportMessage(&#10;            com.dme.LamportMessage.Type.REQUEST,&#10;            myRequestTimestamp,&#10;            processId&#10;        );&#10;&#10;        for (ProcessInfo peer : peers) {&#10;            networkHandler.sendMessage(peer.host, peer.port, request);&#10;        }&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; requested critical section at time &quot; + myRequestTimestamp);&#10;    }&#10;&#10;    private synchronized void checkCriticalSectionEntry() {&#10;        if (!requestingCS) return;&#10;&#10;        // Check if we can enter critical section&#10;        if (replySet.size() == peers.size() &amp;&amp;&#10;            !requestQueue.isEmpty() &amp;&amp;&#10;            requestQueue.peek().processId == processId) {&#10;&#10;            System.out.println(&quot;Process &quot; + processId + &quot; entering critical section&quot;);&#10;            notifyAll(); // Wake up waiting thread&#10;        }&#10;    }&#10;&#10;    public synchronized void waitForCriticalSection() throws InterruptedException {&#10;        while (requestingCS &amp;&amp;&#10;               (replySet.size() &lt; peers.size() ||&#10;                requestQueue.isEmpty() ||&#10;                requestQueue.peek().processId != processId)) {&#10;            wait();&#10;        }&#10;    }&#10;&#10;    public synchronized void releaseCriticalSection() {&#10;        if (!requestingCS) return;&#10;&#10;        requestingCS = false;&#10;&#10;        // Remove own request from queue&#10;        requestQueue.removeIf(req -&gt; req.processId == processId);&#10;&#10;        // Send release to all peers&#10;        com.dme.LamportMessage release = new com.dme.LamportMessage(&#10;            com.dme.LamportMessage.Type.RELEASE,&#10;            clock.tick(),&#10;            processId&#10;        );&#10;&#10;        for (ProcessInfo peer : peers) {&#10;            networkHandler.sendMessage(peer.host, peer.port, release);&#10;        }&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; released critical section&quot;);&#10;    }&#10;&#10;    private ProcessInfo findPeer(int peerId) {&#10;        return peers.stream()&#10;                   .filter(peer -&gt; peer.id == peerId)&#10;                   .findFirst()&#10;                   .orElse(null);&#10;    }&#10;&#10;    public void stop() throws Exception {&#10;        networkHandler.stop();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/FileWriterProcess.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/FileWriterProcess.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.dme;&#10;&#10;import java.io.*;&#10;import java.nio.file.*;&#10;import java.util.*;&#10;&#10;public class FileWriterProcess {&#10;    private static final String SHARED_FILE = &quot;shared_file.txt&quot;;&#10;    private final int processId;&#10;    private final boolean useDME;&#10;    private final com.dme.DistributedMutualExclusion dme;&#10;    private volatile boolean running = true;&#10;&#10;    public FileWriterProcess(int processId, boolean useDME, com.dme.DistributedMutualExclusion dme) {&#10;        this.processId = processId;&#10;        this.useDME = useDME;&#10;        this.dme = dme;&#10;    }&#10;&#10;    public static void main(String[] args) {&#10;        if (args.length &lt; 2) {&#10;            System.err.println(&quot;Usage: java FileWriterProcess &lt;processId&gt; &lt;useDME&gt; [peers...]&quot;);&#10;            System.err.println(&quot;  processId: unique process identifier&quot;);&#10;            System.err.println(&quot;  useDME: true/false to enable/disable distributed mutual exclusion&quot;);&#10;            System.err.println(&quot;  peers: space-separated list of peer addresses in format id:host:port&quot;);&#10;            System.err.println(&quot;Example: java FileWriterProcess 1 true 2:localhost:8002 3:localhost:8003&quot;);&#10;            System.exit(1);&#10;        }&#10;&#10;        try {&#10;            int processId = Integer.parseInt(args[0]);&#10;            boolean useDME = Boolean.parseBoolean(args[1]);&#10;&#10;            com.dme.DistributedMutualExclusion dme = null;&#10;&#10;            if (useDME) {&#10;                // Parse peer information&#10;                List&lt;com.dme.DistributedMutualExclusion.ProcessInfo&gt; peers = new ArrayList&lt;&gt;();&#10;                for (int i = 2; i &lt; args.length; i++) {&#10;                    String[] parts = args[i].split(&quot;:&quot;);&#10;                    if (parts.length != 3) {&#10;                        System.err.println(&quot;Invalid peer format: &quot; + args[i]);&#10;                        System.exit(1);&#10;                    }&#10;                    int peerId = Integer.parseInt(parts[0]);&#10;                    String host = parts[1];&#10;                    int port = Integer.parseInt(parts[2]);&#10;                    peers.add(new com.dme.DistributedMutualExclusion.ProcessInfo(peerId, host, port));&#10;                }&#10;&#10;                // Calculate our port (8000 + processId)&#10;                int myPort = 8000 + processId;&#10;&#10;                dme = new com.dme.DistributedMutualExclusion(processId, myPort, peers);&#10;                dme.start();&#10;&#10;                // Give some time for all processes to start up&#10;                Thread.sleep(2000);&#10;            }&#10;&#10;            FileWriterProcess process = new FileWriterProcess(processId, useDME, dme);&#10;&#10;            // Make dme effectively final for the lambda&#10;            final DistributedMutualExclusion finalDme = dme;&#10;&#10;            // Add shutdown hook for graceful cleanup&#10;            Runtime.getRuntime().addShutdownHook(new Thread(() -&gt; {&#10;                try {&#10;                    process.stop();&#10;                    if (finalDme != null) {&#10;                        finalDme.stop();&#10;                    }&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;Error during shutdown: &quot; + e.getMessage());&#10;                }&#10;            }));&#10;&#10;            process.run();&#10;&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;            System.exit(1);&#10;        }&#10;    }&#10;&#10;    public void run() {&#10;        System.out.println(&quot;Process &quot; + processId + &quot; started. DME: &quot; + useDME);&#10;&#10;        int operationCount = 0;&#10;&#10;        while (running) {&#10;            try {&#10;                if (useDME) {&#10;                    // Request critical section&#10;                    dme.requestCriticalSection();&#10;                    dme.waitForCriticalSection();&#10;                }&#10;&#10;                // Perform the two sequential writes&#10;                writeToFile();&#10;                operationCount++;&#10;&#10;                if (useDME) {&#10;                    // Release critical section&#10;                    dme.releaseCriticalSection();&#10;                }&#10;&#10;                // Small delay between operations&#10;                Thread.sleep(100);&#10;&#10;                // Print status every 10 operations&#10;                if (operationCount % 10 == 0) {&#10;                    System.out.println(&quot;Process &quot; + processId + &quot; completed &quot; + operationCount + &quot; operations&quot;);&#10;                }&#10;&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                break;&#10;            } catch (Exception e) {&#10;                System.err.println(&quot;Process &quot; + processId + &quot; error: &quot; + e.getMessage());&#10;                e.printStackTrace();&#10;                break;&#10;            }&#10;        }&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; stopped after &quot; + operationCount + &quot; operations&quot;);&#10;    }&#10;&#10;    private void writeToFile() throws IOException {&#10;        // Two sequential writes: pipe &quot;|&quot; followed by dot &quot;.&quot;&#10;        try (FileWriter writer = new FileWriter(SHARED_FILE, true)) {&#10;            writer.write(&quot;|&quot;);&#10;            writer.flush();&#10;&#10;            // Small delay to make the sequential nature more visible&#10;            try {&#10;                Thread.sleep(10);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;                return;&#10;            }&#10;&#10;            writer.write(&quot;.&quot;);&#10;            writer.flush();&#10;        }&#10;&#10;        System.out.println(&quot;Process &quot; + processId + &quot; wrote |.&quot;);&#10;    }&#10;&#10;    public void stop() {&#10;        running = false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/LamportClock.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/LamportClock.java" />
              <option name="updatedContent" value="package com.dme;&#10;&#10;public class LamportClock {&#10;    private int timestamp;&#10;    &#10;    public LamportClock() {&#10;        this.timestamp = 0;&#10;    }&#10;    &#10;    public synchronized int tick() {&#10;        return ++timestamp;&#10;    }&#10;    &#10;    public synchronized int getTimestamp() {&#10;        return timestamp;&#10;    }&#10;    &#10;    public synchronized void update(int receivedTimestamp) {&#10;        timestamp = Math.max(timestamp, receivedTimestamp) + 1;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/LamportMessage.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/LamportMessage.java" />
              <option name="updatedContent" value="package com.dme;&#10;&#10;import java.io.Serializable;&#10;&#10;public class LamportMessage implements Serializable {&#10;    public enum Type {&#10;        REQUEST, REPLY, RELEASE&#10;    }&#10;    &#10;    private final Type type;&#10;    private final int timestamp;&#10;    private final int processId;&#10;    &#10;    public LamportMessage(Type type, int timestamp, int processId) {&#10;        this.type = type;&#10;        this.timestamp = timestamp;&#10;        this.processId = processId;&#10;    }&#10;    &#10;    public Type getType() {&#10;        return type;&#10;    }&#10;    &#10;    public int getTimestamp() {&#10;        return timestamp;&#10;    }&#10;    &#10;    public int getProcessId() {&#10;        return processId;&#10;    }&#10;    &#10;    @Override&#10;    public String toString() {&#10;        return String.format(&quot;LamportMessage{type=%s, timestamp=%d, processId=%d}&quot;, &#10;                           type, timestamp, processId);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/Message.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/Message.java" />
              <option name="updatedContent" value="package com.dme;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/dme/NetworkHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/dme/NetworkHandler.java" />
              <option name="updatedContent" value="package com.dme;&#10;&#10;import java.io.*;&#10;import java.net.*;&#10;import java.util.concurrent.BlockingQueue;&#10;import java.util.concurrent.LinkedBlockingQueue;&#10;&#10;public class NetworkHandler {&#10;    private final int port;&#10;    private final BlockingQueue&lt;LamportMessage&gt; incomingMessages;&#10;    private ServerSocket serverSocket;&#10;    private volatile boolean running = false;&#10;    &#10;    public NetworkHandler(int port) {&#10;        this.port = port;&#10;        this.incomingMessages = new LinkedBlockingQueue&lt;&gt;();&#10;    }&#10;    &#10;    public void start() throws IOException {&#10;        serverSocket = new ServerSocket(port);&#10;        running = true;&#10;        &#10;        // Start server thread to accept incoming connections&#10;        new Thread(this::acceptConnections).start();&#10;        &#10;        System.out.println(&quot;NetworkHandler started on port &quot; + port);&#10;    }&#10;    &#10;    private void acceptConnections() {&#10;        while (running) {&#10;            try {&#10;                Socket clientSocket = serverSocket.accept();&#10;                new Thread(() -&gt; handleClient(clientSocket)).start();&#10;            } catch (IOException e) {&#10;                if (running) {&#10;                    System.err.println(&quot;Error accepting connection: &quot; + e.getMessage());&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    private void handleClient(Socket clientSocket) {&#10;        try (ObjectInputStream ois = new ObjectInputStream(clientSocket.getInputStream())) {&#10;            LamportMessage message = (LamportMessage) ois.readObject();&#10;            incomingMessages.offer(message);&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;Error handling client: &quot; + e.getMessage());&#10;        } finally {&#10;            try {&#10;                clientSocket.close();&#10;            } catch (IOException e) {&#10;                // Ignore close errors&#10;            }&#10;        }&#10;    }&#10;    &#10;    public void sendMessage(String host, int port, LamportMessage message) {&#10;        try (Socket socket = new Socket(host, port);&#10;             ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream())) {&#10;            oos.writeObject(message);&#10;            oos.flush();&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error sending message to &quot; + host + &quot;:&quot; + port + &quot; - &quot; + e.getMessage());&#10;        }&#10;    }&#10;    &#10;    public LamportMessage receiveMessage() throws InterruptedException {&#10;        return incomingMessages.take();&#10;    }&#10;    &#10;    public LamportMessage receiveMessageNonBlocking() {&#10;        return incomingMessages.poll();&#10;    }&#10;    &#10;    public void stop() throws IOException {&#10;        running = false;&#10;        if (serverSocket != null &amp;&amp; !serverSocket.isClosed()) {&#10;            serverSocket.close();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>